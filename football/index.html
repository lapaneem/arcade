<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Football</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { background: #0a0a0a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; }

    #start-overlay {
      position: absolute; top:0; left:0; right:0; bottom:0;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; background: rgba(0,0,0,0.9); z-index: 100;
    }
    #start-overlay.hidden { display: none; }
    #start-overlay h1 { font-size: 48px; margin-bottom: 6px; color: #8b4513; }
    #start-overlay .sub { font-size: 22px; color: #f0a500; margin-bottom: 16px; }
    #start-overlay p { font-size: 15px; color: #aaa; margin-bottom: 4px; }
    .start-btn {
      margin-top: 20px; padding: 16px 46px; font-size: 24px; font-weight: bold;
      border: 3px solid #8b4513; border-radius: 12px; cursor: pointer; color: #fff;
      background: rgba(22,33,62,0.9); transition: all 0.15s;
    }
    .start-btn:hover { border-color: #f0a500; box-shadow: 0 0 25px rgba(240,165,0,0.3); }
    .controls-info { margin-top: 18px; color: #555; font-size: 13px; line-height: 1.8; text-align: center; }

    #msg-overlay {
      position: absolute; top:0; left:0; right:0; bottom:0;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; background: rgba(0,0,0,0.6); z-index: 90; pointer-events: none;
    }
    #msg-overlay.hidden { display: none; }
    #msg-overlay h1 { font-size: 56px; text-shadow: 0 0 30px rgba(240,165,0,0.6); }
    #msg-overlay p { font-size: 24px; margin-top: 8px; color: #aaa; }

    #hud {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 16px; align-items: center; z-index: 50;
      font-weight: bold; color: #fff; text-shadow: 0 0 8px rgba(0,0,0,0.8);
      background: rgba(0,0,0,0.5); padding: 6px 20px; border-radius: 14px; font-size: 20px;
    }
    #hud.hidden { display: none; }
    .h-p1 { color: #4fc3f7; }
    .h-p2 { color: #ff8800; }
    .h-sep { color: #444; }
    #hud-info { font-size: 14px; color: #aaa; }

    /* Touch controls */
    #touch-p1, #touch-p2 { display: none; position: fixed; z-index: 60; pointer-events: none; }
    @media (hover: none) and (pointer: coarse) { #touch-p1, #touch-p2 { display: block; } }
    #touch-p1 { bottom: 8px; left: 8px; }
    #touch-p2 { bottom: 8px; right: 8px; }
    .tc { display: flex; align-items: center; gap: 6px; pointer-events: auto; }
    .tc.rs { flex-direction: row-reverse; }
    .tdp { display: grid; grid-template-columns: 44px 44px 44px; grid-template-rows: 44px 44px 44px; gap: 3px; }
    .td {
      width: 44px; height: 44px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px; color: #fff; font-size: 17px;
      display: flex; align-items: center; justify-content: center;
      user-select: none; -webkit-user-select: none; pointer-events: auto;
    }
    .td:active { background: rgba(255,255,255,0.3); }
    .td.empty { background: none; border: none; pointer-events: none; }
    #touch-p1 .td { border-color: rgba(79,195,247,0.3); }
    #touch-p2 .td { border-color: rgba(255,136,0,0.3); }
    .tact {
      width: 64px; height: 64px; border-radius: 50%;
      background: rgba(139,69,19,0.3); border: 3px solid rgba(139,69,19,0.6);
      color: #fff; font-size: 11px; font-weight: bold;
      display: flex; align-items: center; justify-content: center;
      user-select: none; -webkit-user-select: none; pointer-events: auto;
    }
    .tact:active { background: rgba(139,69,19,0.55); }
    #touch-p2 .tact { background: rgba(255,136,0,0.2); border-color: rgba(255,136,0,0.5); }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud" class="hidden">
    <span class="h-p1" id="hp1">P1: 0</span>
    <span class="h-sep">|</span>
    <span class="h-p2" id="hp2">P2: 0</span>
    <span class="h-sep">|</span>
    <span id="hud-info">1st Down</span>
  </div>

  <div id="msg-overlay" class="hidden">
    <h1 id="msg-title"></h1>
    <p id="msg-sub"></p>
  </div>

  <div id="start-overlay">
    <h1>üèà Football</h1>
    <div class="sub">2 Player VS</div>
    <p>Offense runs the ball to the end zone!</p>
    <p>Defense tries to tackle!</p>
    <p style="color:#f0a500;margin-top:8px;">4 drives each ‚Äî most points wins!</p>
    <button class="start-btn" id="start-btn">KICK OFF</button>
    <div class="controls-info">
      P1 (Blue): <b>WASD</b> move &bull; <b>Space</b> throw/sprint<br>
      P2 (Orange): <b>Arrows</b> move &bull; <b>Enter</b> sprint/dive<br>
      Offense: press action to <b>throw</b> the ball forward!<br>
      Defense: press action near carrier to <b>dive tackle</b>!
    </div>
  </div>

  <div id="touch-p1">
    <div class="tc">
      <div class="tdp">
        <div class="td empty"></div><div class="td" data-p="1" data-k="up">&#9650;</div><div class="td empty"></div>
        <div class="td" data-p="1" data-k="left">&#9664;</div><div class="td empty"></div><div class="td" data-p="1" data-k="right">&#9654;</div>
        <div class="td empty"></div><div class="td" data-p="1" data-k="down">&#9660;</div><div class="td empty"></div>
      </div>
      <div class="tact" data-p="1" data-k="act">ACT</div>
    </div>
  </div>
  <div id="touch-p2">
    <div class="tc rs">
      <div class="tdp">
        <div class="td empty"></div><div class="td" data-p="2" data-k="up">&#9650;</div><div class="td empty"></div>
        <div class="td" data-p="2" data-k="left">&#9664;</div><div class="td empty"></div><div class="td" data-p="2" data-k="right">&#9654;</div>
        <div class="td empty"></div><div class="td" data-p="2" data-k="down">&#9660;</div><div class="td empty"></div>
      </div>
      <div class="tact" data-p="2" data-k="act">ACT</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('start-overlay');
    const msgOverlay = document.getElementById('msg-overlay');
    const msgTitle = document.getElementById('msg-title');
    const msgSub = document.getElementById('msg-sub');
    const hud = document.getElementById('hud');
    const hp1 = document.getElementById('hp1');
    const hp2 = document.getElementById('hp2');
    const hudInfo = document.getElementById('hud-info');

    let W, H;
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    const touch = { 1: {}, 2: {} };
    document.querySelectorAll('[data-p]').forEach(el => {
      const p = el.dataset.p, k = el.dataset.k;
      el.addEventListener('touchstart', e => { e.preventDefault(); touch[p][k] = true; }, { passive: false });
      el.addEventListener('touchend', e => { e.preventDefault(); touch[p][k] = false; }, { passive: false });
      el.addEventListener('touchcancel', () => { touch[p][k] = false; });
    });

    // Field
    const FIELD_YARDS = 100;
    const ENDZONE_W = 40;
    const PLAYER_R = 14;
    const PLAYER_SPEED = 3.5;
    const SPRINT_SPEED = 5.2;
    const TACKLE_RANGE = 30;
    const DIVE_RANGE = 50;
    const BALL_R = 6;
    const TOTAL_DRIVES = 8; // 4 each

    let fieldX, fieldY, fieldW, fieldH, yardW;
    function calcField() {
      fieldW = Math.min(W - 40, 800);
      fieldH = Math.min(H - 100, 360);
      fieldX = (W - fieldW) / 2;
      fieldY = (H - fieldH) / 2;
      yardW = (fieldW - ENDZONE_W * 2) / FIELD_YARDS;
    }

    function yardToX(yard) { return fieldX + ENDZONE_W + yard * yardW; }
    function xToYard(x) { return (x - fieldX - ENDZONE_W) / yardW; }

    let p1Score, p2Score, driveNum, offense; // offense: 1 or 2
    let players, ballCarrier, ball, thrownBall;
    let lineOfScrimmage, down, yardsToGo, firstDownLine;
    let gameStarted, playing, pauseTimer, particles;
    let actPressed1, actPressed2; // to prevent hold-spam

    function makePlayer(x, y, color, id) {
      return { x, y, color, id, vx: 0, vy: 0, diving: false, diveTimer: 0 };
    }

    function setupDrive() {
      lineOfScrimmage = 20;
      down = 1;
      yardsToGo = 10;
      firstDownLine = lineOfScrimmage + 10;
      thrownBall = null;
      setupPlay();
    }

    function setupPlay() {
      const losX = yardToX(lineOfScrimmage);
      const cy = fieldY + fieldH / 2;
      thrownBall = null;

      if (offense === 1) {
        players = [
          makePlayer(losX - 10, cy, '#4fc3f7', 1),
          makePlayer(losX + 40, cy, '#ff8800', 2),
        ];
        ballCarrier = players[0];
      } else {
        players = [
          makePlayer(losX + 40, cy, '#4fc3f7', 1),
          makePlayer(losX - 10, cy, '#ff8800', 2),
        ];
        ballCarrier = players[1];
      }
      ball = { x: ballCarrier.x, y: ballCarrier.y };
      updateHUD();
    }

    function init() {
      calcField();
      p1Score = 0; p2Score = 0;
      driveNum = 1;
      offense = 1;
      playing = true;
      pauseTimer = 0;
      particles = [];
      actPressed1 = false; actPressed2 = false;
      setupDrive();
      updateScoreUI();
    }

    function updateScoreUI() {
      hp1.textContent = `P1: ${p1Score}`;
      hp2.textContent = `P2: ${p2Score}`;
    }

    function updateHUD() {
      const downNames = ['', '1st', '2nd', '3rd', '4th'];
      const offLabel = offense === 1 ? 'P1' : 'P2';
      const offColor = offense === 1 ? '#4fc3f7' : '#ff8800';
      hudInfo.innerHTML = `<span style="color:${offColor}">${offLabel} ball</span> &bull; ${downNames[down]} & ${Math.round(yardsToGo)}`;
    }

    function spawnParticles(x, y, color, count, speed) {
      for (let i = 0; i < count; i++) {
        const a = Math.random()*Math.PI*2, s = Math.random()*speed+1;
        particles.push({ x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s,
          radius:Math.random()*3+1, color, life:400+Math.random()*300, maxLife:700 });
      }
    }

    function showMessage(title, sub, duration, callback) {
      msgOverlay.classList.remove('hidden');
      msgTitle.innerHTML = title;
      msgSub.textContent = sub;
      playing = false;
      pauseTimer = duration;
      setTimeout(() => {
        msgOverlay.classList.add('hidden');
        if (callback) callback();
        playing = true;
      }, duration);
    }

    function handleTouchdown() {
      if (offense === 1) p1Score += 7;
      else p2Score += 7;
      updateScoreUI();
      const scorer = offense === 1 ? 'P1' : 'P2';
      const color = offense === 1 ? '#4fc3f7' : '#ff8800';
      spawnParticles(ballCarrier.x, ballCarrier.y, '#f0a500', 30, 8);
      spawnParticles(ballCarrier.x, ballCarrier.y, color, 20, 6);
      showMessage(`<span style="color:#f0a500">TOUCHDOWN!</span>`, `${scorer} scores! +7 points`, 2000, () => {
        nextDrive();
      });
    }

    function handleTackle() {
      spawnParticles(ballCarrier.x, ballCarrier.y, '#ff4444', 15, 5);
      const newYard = xToYard(ballCarrier.x);

      // Check first down
      if (newYard >= firstDownLine) {
        lineOfScrimmage = newYard;
        down = 1;
        yardsToGo = 10;
        firstDownLine = Math.min(lineOfScrimmage + 10, FIELD_YARDS);
        showMessage('<span style="color:#53d769">FIRST DOWN!</span>', '', 1200, () => { setupPlay(); });
        return;
      }

      down++;
      yardsToGo = firstDownLine - newYard;
      lineOfScrimmage = newYard;

      if (down > 4) {
        // Turnover on downs
        showMessage('<span style="color:#e94560">TURNOVER ON DOWNS!</span>', '', 1500, () => { nextDrive(); });
        return;
      }

      showMessage(`<span style="color:#aaa">TACKLED</span>`, `${['','1st','2nd','3rd','4th'][down]} & ${Math.round(yardsToGo)}`, 1200, () => { setupPlay(); });
    }

    function handleInterception() {
      const def = offense === 1 ? 'P2' : 'P1';
      const color = offense === 1 ? '#ff8800' : '#4fc3f7';
      spawnParticles(thrownBall.x, thrownBall.y, color, 20, 6);
      showMessage(`<span style="color:${color}">INTERCEPTION!</span>`, `${def} picks it off!`, 1800, () => { nextDrive(); });
    }

    function handleIncomplete() {
      down++;
      yardsToGo = firstDownLine - lineOfScrimmage;
      if (down > 4) {
        showMessage('<span style="color:#e94560">TURNOVER ON DOWNS!</span>', '', 1500, () => { nextDrive(); });
        return;
      }
      showMessage('<span style="color:#aaa">INCOMPLETE</span>', `${['','1st','2nd','3rd','4th'][down]} & ${Math.round(yardsToGo)}`, 1000, () => { setupPlay(); });
    }

    function nextDrive() {
      driveNum++;
      if (driveNum > TOTAL_DRIVES) {
        gameOver();
        return;
      }
      offense = offense === 1 ? 2 : 1;
      setupDrive();
    }

    function gameOver() {
      const winner = p1Score > p2Score ? 'P1 WINS!' : p2Score > p1Score ? 'P2 WINS!' : 'TIE GAME!';
      const wColor = p1Score > p2Score ? '#4fc3f7' : p2Score > p1Score ? '#ff8800' : '#aaa';
      msgOverlay.classList.remove('hidden');
      msgTitle.innerHTML = `<span style="color:${wColor}">${winner}</span>`;
      msgSub.textContent = `${p1Score} - ${p2Score} ‚Ä¢ Tap to play again`;
      playing = false;
      setTimeout(() => {
        const restart = () => {
          document.removeEventListener('click', restart);
          document.removeEventListener('keydown', restart);
          msgOverlay.classList.add('hidden');
          init();
        };
        document.addEventListener('click', restart);
        document.addEventListener('keydown', restart);
      }, 1200);
    }

    // Update
    let lastTs = null;
    function update(dt) {
      if (!playing) {
        for (let i = particles.length-1; i>=0; i--) {
          const p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.life-=dt;
          if (p.life<=0) particles.splice(i,1);
        }
        return;
      }

      // Action button tracking (press once, not hold)
      const act1Now = !!(keys[' '] || touch[1].act);
      const act2Now = !!(keys['Enter'] || touch[2].act);
      const act1Tap = act1Now && !actPressed1;
      const act2Tap = act2Now && !actPressed2;
      actPressed1 = act1Now;
      actPressed2 = act2Now;

      for (const p of players) {
        if (p.diving) {
          p.diveTimer -= dt;
          p.x += p.vx; p.y += p.vy;
          p.vx *= 0.94; p.vy *= 0.94;
          if (p.diveTimer <= 0) { p.diving = false; }
          continue;
        }

        let dx = 0, dy = 0, actTap = false, actHold = false;
        if (p.id === 1) {
          if (keys['w']||keys['W']||touch[1].up) dy = -1;
          if (keys['s']||keys['S']||touch[1].down) dy = 1;
          if (keys['a']||keys['A']||touch[1].left) dx = -1;
          if (keys['d']||keys['D']||touch[1].right) dx = 1;
          actTap = act1Tap;
          actHold = act1Now;
        } else {
          if (keys['ArrowUp']||touch[2].up) dy = -1;
          if (keys['ArrowDown']||touch[2].down) dy = 1;
          if (keys['ArrowLeft']||touch[2].left) dx = -1;
          if (keys['ArrowRight']||touch[2].right) dx = 1;
          actTap = act2Tap;
          actHold = act2Now;
        }

        if (dx || dy) { const l = Math.hypot(dx,dy); dx/=l; dy/=l; }

        const isOffense = p.id === offense;
        const isBallCarrier = ballCarrier === p;
        const spd = (actHold && !actTap) ? SPRINT_SPEED : PLAYER_SPEED;
        p.x += dx * spd;
        p.y += dy * spd;

        // Clamp to field
        p.x = Math.max(fieldX + PLAYER_R, Math.min(fieldX + fieldW - PLAYER_R, p.x));
        p.y = Math.max(fieldY + PLAYER_R, Math.min(fieldY + fieldH - PLAYER_R, p.y));

        // Offense action: throw ball
        if (isOffense && isBallCarrier && actTap && !thrownBall) {
          // Throw ball forward (toward opponent's endzone)
          const throwDir = 0; // right = toward endzone
          const throwAngle = Math.atan2(dy, dx || 1);
          thrownBall = {
            x: p.x, y: p.y,
            vx: Math.cos(throwAngle) * 9 + 3,
            vy: Math.sin(throwAngle) * 5,
            life: 800,
          };
          ballCarrier = null;
        }

        // Defense action: dive tackle
        if (!isOffense && actTap) {
          const target = ballCarrier || (thrownBall ? { x: thrownBall.x, y: thrownBall.y } : null);
          if (target) {
            const a = Math.atan2(target.y - p.y, target.x - p.x);
            p.vx = Math.cos(a) * 8;
            p.vy = Math.sin(a) * 8;
            p.diving = true;
            p.diveTimer = 400;
          }
        }
      }

      // Player collision
      const p0 = players[0], p1p = players[1];
      const pd = Math.hypot(p0.x-p1p.x, p0.y-p1p.y);
      if (pd < PLAYER_R * 2 && pd > 0) {
        const overlap = PLAYER_R*2 - pd;
        const ax = (p0.x-p1p.x)/pd, ay = (p0.y-p1p.y)/pd;
        p0.x += ax*overlap/2; p0.y += ay*overlap/2;
        p1p.x -= ax*overlap/2; p1p.y -= ay*overlap/2;
      }

      // Tackle check
      if (ballCarrier) {
        const defender = players.find(p => p.id !== offense);
        const dist = Math.hypot(ballCarrier.x - defender.x, ballCarrier.y - defender.y);
        const range = defender.diving ? DIVE_RANGE : TACKLE_RANGE;
        if (dist < range) {
          handleTackle();
          return;
        }

        // Ball follows carrier
        ball.x = ballCarrier.x;
        ball.y = ballCarrier.y;

        // Touchdown check
        const yard = xToYard(ballCarrier.x);
        if (yard >= FIELD_YARDS) {
          handleTouchdown();
          return;
        }

        // Safety check (run behind own endzone)
        if (yard < 0) {
          const def = offense === 1 ? 'P2' : 'P1';
          const defColor = offense === 1 ? '#ff8800' : '#4fc3f7';
          if (offense === 1) p2Score += 2; else p1Score += 2;
          updateScoreUI();
          spawnParticles(ballCarrier.x, ballCarrier.y, defColor, 20, 6);
          showMessage(`<span style="color:${defColor}">SAFETY!</span>`, `${def} gets 2 points!`, 1800, () => { nextDrive(); });
          return;
        }
      }

      // Thrown ball
      if (thrownBall) {
        thrownBall.x += thrownBall.vx;
        thrownBall.y += thrownBall.vy;
        thrownBall.life -= dt;
        ball.x = thrownBall.x;
        ball.y = thrownBall.y;

        // Defense catch (interception)
        const defender = players.find(p => p.id !== offense);
        if (Math.hypot(thrownBall.x - defender.x, thrownBall.y - defender.y) < PLAYER_R + BALL_R + 5) {
          handleInterception();
          return;
        }

        // Out of bounds or expired
        if (thrownBall.life <= 0 ||
            thrownBall.x < fieldX || thrownBall.x > fieldX + fieldW ||
            thrownBall.y < fieldY || thrownBall.y > fieldY + fieldH) {
          handleIncomplete();
          return;
        }

        // Touchdown via throw
        if (xToYard(thrownBall.x) >= FIELD_YARDS) {
          // Need a receiver... treat as incomplete if nobody catches it
          handleIncomplete();
          return;
        }
      }

      // Particles
      for (let i = particles.length-1; i>=0; i--) {
        const p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.life-=dt;
        if (p.life<=0) particles.splice(i,1);
      }
    }

    // Draw
    function draw() {
      calcField();
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, W, H);

      // End zones
      ctx.fillStyle = 'rgba(79,195,247,0.15)';
      ctx.fillRect(fieldX, fieldY, ENDZONE_W, fieldH);
      ctx.fillStyle = 'rgba(255,136,0,0.15)';
      ctx.fillRect(fieldX + fieldW - ENDZONE_W, fieldY, ENDZONE_W, fieldH);

      // Endzone text
      ctx.save();
      ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(79,195,247,0.3)';
      ctx.translate(fieldX + ENDZONE_W/2, fieldY + fieldH/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('END ZONE', 0, 0);
      ctx.restore();
      ctx.save();
      ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(255,136,0,0.3)';
      ctx.translate(fieldX + fieldW - ENDZONE_W/2, fieldY + fieldH/2);
      ctx.rotate(Math.PI/2);
      ctx.fillText('END ZONE', 0, 0);
      ctx.restore();

      // Field green
      const playFieldX = fieldX + ENDZONE_W;
      const playFieldW = fieldW - ENDZONE_W * 2;
      ctx.fillStyle = '#1a5c2e';
      ctx.fillRect(playFieldX, fieldY, playFieldW, fieldH);

      // Yard lines
      ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1;
      ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.fillStyle = 'rgba(255,255,255,0.25)';
      for (let yd = 0; yd <= 100; yd += 5) {
        const x = yardToX(yd);
        if (yd % 10 === 0) {
          ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1.5;
        } else {
          ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
        }
        ctx.beginPath(); ctx.moveTo(x, fieldY); ctx.lineTo(x, fieldY + fieldH); ctx.stroke();
        if (yd % 10 === 0 && yd > 0 && yd < 100) {
          const label = yd <= 50 ? yd : 100 - yd;
          ctx.fillText(label, x, fieldY + 14);
          ctx.fillText(label, x, fieldY + fieldH - 8);
        }
      }

      // Hash marks
      ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
      const hashY1 = fieldY + fieldH * 0.33;
      const hashY2 = fieldY + fieldH * 0.67;
      for (let yd = 1; yd < 100; yd++) {
        if (yd % 5 === 0) continue;
        const x = yardToX(yd);
        ctx.beginPath(); ctx.moveTo(x, hashY1 - 4); ctx.lineTo(x, hashY1 + 4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, hashY2 - 4); ctx.lineTo(x, hashY2 + 4); ctx.stroke();
      }

      // Line of scrimmage
      const losX = yardToX(lineOfScrimmage);
      ctx.strokeStyle = 'rgba(79,195,247,0.5)'; ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath(); ctx.moveTo(losX, fieldY); ctx.lineTo(losX, fieldY + fieldH); ctx.stroke();
      ctx.setLineDash([]);

      // First down line
      if (firstDownLine <= FIELD_YARDS) {
        const fdX = yardToX(firstDownLine);
        ctx.strokeStyle = 'rgba(255,255,0,0.5)'; ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(fdX, fieldY); ctx.lineTo(fdX, fieldY + fieldH); ctx.stroke();
        ctx.setLineDash([]);
      }

      // Field border
      ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 3;
      ctx.strokeRect(fieldX, fieldY, fieldW, fieldH);

      if (!players) return;

      // Players
      for (const p of players) {
        const isOff = p.id === offense;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(p.x+2, p.y+3, PLAYER_R, PLAYER_R*0.5, 0, 0, Math.PI*2); ctx.fill();

        // Body
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color; ctx.shadowBlur = 8;
        if (p.diving) {
          // Diving ‚Äî stretched oval
          ctx.save();
          const da = Math.atan2(p.vy, p.vx);
          ctx.translate(p.x, p.y);
          ctx.rotate(da);
          ctx.beginPath(); ctx.ellipse(0, 0, PLAYER_R * 1.4, PLAYER_R * 0.7, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        } else {
          ctx.beginPath(); ctx.arc(p.x, p.y, PLAYER_R, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Inner
        const inner = p.id === 1 ? '#3aa0d0' : '#cc6600';
        ctx.fillStyle = inner;
        if (!p.diving) {
          ctx.beginPath(); ctx.arc(p.x, p.y, PLAYER_R*0.5, 0, Math.PI*2); ctx.fill();
        }

        // Number
        ctx.fillStyle = '#fff'; ctx.font = `bold ${PLAYER_R*0.7}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        if (!p.diving) ctx.fillText(p.id, p.x, p.y+1);

        // Label
        ctx.fillStyle = p.color; ctx.globalAlpha = 0.7;
        ctx.font = 'bold 10px sans-serif';
        const role = isOff ? 'OFF' : 'DEF';
        ctx.fillText(`P${p.id} ${role}`, p.x, p.y - PLAYER_R - 8);
        ctx.globalAlpha = 1;
      }

      // Ball
      if (ball) {
        ctx.fillStyle = '#8b4513';
        ctx.shadowColor = '#8b4513'; ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.ellipse(ball.x, ball.y, BALL_R * 1.5, BALL_R, 0, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        // Laces
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(ball.x - 3, ball.y); ctx.lineTo(ball.x + 3, ball.y); ctx.stroke();
        for (let i = -1; i <= 1; i++) {
          ctx.beginPath(); ctx.moveTo(ball.x + i * 3, ball.y - 2); ctx.lineTo(ball.x + i * 3, ball.y + 2); ctx.stroke();
        }
      }

      // Thrown ball trail
      if (thrownBall) {
        ctx.globalAlpha = 0.3; ctx.fillStyle = '#8b4513';
        ctx.beginPath(); ctx.ellipse(thrownBall.x - thrownBall.vx, thrownBall.y - thrownBall.vy, BALL_R, BALL_R * 0.6, 0, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Drive counter
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.font = '12px sans-serif'; ctx.textAlign = 'right';
      ctx.fillText(`Drive ${driveNum}/${TOTAL_DRIVES}`, fieldX + fieldW - 4, fieldY - 6);
    }

    function gameLoop(ts) {
      if (!lastTs) lastTs = ts;
      let dt = ts - lastTs; lastTs = ts;
      if (dt > 50) dt = 50;
      if (gameStarted) { update(dt); draw(); }
      requestAnimationFrame(gameLoop);
    }

    gameStarted = false;
    document.getElementById('start-btn').addEventListener('click', () => {
      gameStarted = true;
      startOverlay.classList.add('hidden');
      hud.classList.remove('hidden');
      init();
    });

    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>
