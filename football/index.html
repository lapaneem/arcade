<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>Football</title>
  <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    body { background: #0a0a0a; overflow: hidden; font-family: 'Segoe UI', Tahoma, sans-serif; }
    canvas { display: block; }

    #start-overlay {
      position: absolute; top:0; left:0; right:0; bottom:0;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; background: rgba(0,0,0,0.9); z-index: 100;
    }
    #start-overlay.hidden { display: none; }
    #start-overlay h1 { font-size: 48px; margin-bottom: 6px; color: #8b4513; }
    #start-overlay .sub { font-size: 22px; color: #f0a500; margin-bottom: 16px; }
    #start-overlay p { font-size: 15px; color: #aaa; margin-bottom: 4px; }

    .lobby-btn {
      margin: 6px; padding: 14px 36px; font-size: 20px; font-weight: bold;
      border: 3px solid #8b4513; border-radius: 12px; cursor: pointer; color: #fff;
      background: rgba(22,33,62,0.9); transition: all 0.15s;
    }
    .lobby-btn:hover { border-color: #f0a500; box-shadow: 0 0 25px rgba(240,165,0,0.3); }
    .lobby-btn:disabled { opacity: 0.4; cursor: default; border-color: #444; box-shadow: none; }
    .btn-row { display: flex; flex-wrap: wrap; justify-content: center; margin-top: 16px; }

    #lobby-host, #lobby-join { display: none; text-align: center; margin-top: 16px; }
    .room-code {
      font-size: 36px; font-weight: bold; letter-spacing: 8px; color: #f0a500;
      background: rgba(255,255,255,0.05); padding: 10px 24px; border-radius: 10px;
      display: inline-block; margin: 10px 0; font-family: monospace;
    }
    .lobby-status { color: #aaa; font-size: 15px; margin-top: 8px; }
    .lobby-status.error { color: #e94560; }
    #join-input {
      font-size: 24px; letter-spacing: 6px; text-align: center; width: 200px;
      padding: 10px 16px; border: 2px solid #8b4513; border-radius: 10px;
      background: rgba(255,255,255,0.05); color: #f0a500; font-family: monospace;
      text-transform: uppercase; outline: none;
    }
    #join-input:focus { border-color: #f0a500; }
    #join-input::placeholder { color: #555; letter-spacing: 2px; font-size: 16px; }

    .controls-info { margin-top: 18px; color: #555; font-size: 13px; line-height: 1.8; text-align: center; }

    #msg-overlay {
      position: absolute; top:0; left:0; right:0; bottom:0;
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: #fff; background: rgba(0,0,0,0.6); z-index: 90; pointer-events: none;
    }
    #msg-overlay.hidden { display: none; }
    #msg-overlay h1 { font-size: 56px; text-shadow: 0 0 30px rgba(240,165,0,0.6); }
    #msg-overlay p { font-size: 24px; margin-top: 8px; color: #aaa; }

    #hud {
      position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 16px; align-items: center; z-index: 50;
      font-weight: bold; color: #fff; text-shadow: 0 0 8px rgba(0,0,0,0.8);
      background: rgba(0,0,0,0.5); padding: 6px 20px; border-radius: 14px; font-size: 20px;
    }
    #hud.hidden { display: none; }
    .h-p1 { color: #4fc3f7; }
    .h-p2 { color: #ff8800; }
    .h-p3 { color: #66bb6a; }
    .h-sep { color: #444; }
    #hud-info { font-size: 14px; color: #aaa; }

    /* Touch controls */
    #touch-controls { display: none; position: fixed; z-index: 60; pointer-events: none; bottom: 8px; left: 8px; }
    @media (hover: none) and (pointer: coarse) { #touch-controls { display: block; } }
    .tc { display: flex; align-items: center; gap: 6px; pointer-events: auto; }
    .tdp { display: grid; grid-template-columns: 44px 44px 44px; grid-template-rows: 44px 44px 44px; gap: 3px; }
    .td {
      width: 44px; height: 44px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
      border-radius: 10px; color: #fff; font-size: 17px;
      display: flex; align-items: center; justify-content: center;
      user-select: none; -webkit-user-select: none; pointer-events: auto;
    }
    .td:active { background: rgba(255,255,255,0.3); }
    .td.empty { background: none; border: none; pointer-events: none; }
    .tact {
      width: 64px; height: 64px; border-radius: 50%;
      background: rgba(139,69,19,0.3); border: 3px solid rgba(139,69,19,0.6);
      color: #fff; font-size: 11px; font-weight: bold;
      display: flex; align-items: center; justify-content: center;
      user-select: none; -webkit-user-select: none; pointer-events: auto;
    }
    .tact:active { background: rgba(139,69,19,0.55); }

    /* Local 2-player touch */
    #touch-p1-local, #touch-p2-local { display: none; position: fixed; z-index: 60; pointer-events: none; }
    @media (hover: none) and (pointer: coarse) { #touch-p1-local, #touch-p2-local { display: block; } }
    #touch-p1-local { bottom: 8px; left: 8px; }
    #touch-p2-local { bottom: 8px; right: 8px; }
    #touch-p2-local .tc { flex-direction: row-reverse; }
    #touch-p1-local .td { border-color: rgba(79,195,247,0.3); }
    #touch-p2-local .td { border-color: rgba(255,136,0,0.3); }
    #touch-p2-local .tact { background: rgba(255,136,0,0.2); border-color: rgba(255,136,0,0.5); }
  </style>
</head>
<body>
  <canvas id="game"></canvas>

  <div id="hud" class="hidden">
    <span class="h-p1" id="hp1">P1: 0</span>
    <span class="h-sep">|</span>
    <span class="h-p2" id="hp2">P2: 0</span>
    <span class="h-sep">|</span>
    <span class="h-p3" id="hp3" style="display:none">P3: 0</span>
    <span class="h-sep" id="sep3" style="display:none">|</span>
    <span id="hud-info">1st Down</span>
  </div>

  <div id="msg-overlay" class="hidden">
    <h1 id="msg-title"></h1>
    <p id="msg-sub"></p>
  </div>

  <div id="start-overlay">
    <h1>üèà Football</h1>
    <div class="sub">American Football</div>
    <p>Offense runs the ball to the end zone!</p>
    <p>Defense tries to tackle!</p>

    <div id="lobby-mode-select">
      <div class="btn-row">
        <button class="lobby-btn" id="btn-local">PLAY LOCAL (2P)</button>
        <button class="lobby-btn" id="btn-create">CREATE GAME</button>
        <button class="lobby-btn" id="btn-join">JOIN GAME</button>
      </div>
      <div class="controls-info">
        Local: P1 <b>WASD</b> + <b>Space</b> &bull; P2 <b>Arrows</b> + <b>Enter</b><br>
        Online: Any keys or touch ‚Äî you control your own player
      </div>
    </div>

    <div id="lobby-host">
      <p style="color:#f0a500;font-size:18px;">Room Code:</p>
      <div class="room-code" id="host-code">-----</div>
      <div class="lobby-status" id="host-status">Creating room...</div>
      <button class="lobby-btn" id="btn-host-back" style="margin-top:14px;font-size:14px;padding:8px 20px;">Back</button>
    </div>

    <div id="lobby-join">
      <p style="color:#aaa;margin-bottom:10px;">Enter room code:</p>
      <input type="text" id="join-input" maxlength="5" placeholder="CODE" autocomplete="off" autocapitalize="characters" spellcheck="false">
      <br>
      <button class="lobby-btn" id="btn-join-go" style="margin-top:12px;">JOIN</button>
      <div class="lobby-status" id="join-status"></div>
      <button class="lobby-btn" id="btn-join-back" style="margin-top:10px;font-size:14px;padding:8px 20px;">Back</button>
    </div>
  </div>

  <!-- Online touch controls (single set) -->
  <div id="touch-controls">
    <div class="tc">
      <div class="tdp">
        <div class="td empty"></div><div class="td" data-k="up">&#9650;</div><div class="td empty"></div>
        <div class="td" data-k="left">&#9664;</div><div class="td empty"></div><div class="td" data-k="right">&#9654;</div>
        <div class="td empty"></div><div class="td" data-k="down">&#9660;</div><div class="td empty"></div>
      </div>
      <div class="tact" data-k="act">ACT</div>
    </div>
  </div>

  <!-- Local 2P touch controls -->
  <div id="touch-p1-local">
    <div class="tc">
      <div class="tdp">
        <div class="td empty"></div><div class="td" data-p="1" data-k="up">&#9650;</div><div class="td empty"></div>
        <div class="td" data-p="1" data-k="left">&#9664;</div><div class="td empty"></div><div class="td" data-p="1" data-k="right">&#9654;</div>
        <div class="td empty"></div><div class="td" data-p="1" data-k="down">&#9660;</div><div class="td empty"></div>
      </div>
      <div class="tact" data-p="1" data-k="act">ACT</div>
    </div>
  </div>
  <div id="touch-p2-local">
    <div class="tc">
      <div class="tdp">
        <div class="td empty"></div><div class="td" data-p="2" data-k="up">&#9650;</div><div class="td empty"></div>
        <div class="td" data-p="2" data-k="left">&#9664;</div><div class="td empty"></div><div class="td" data-p="2" data-k="right">&#9654;</div>
        <div class="td empty"></div><div class="td" data-p="2" data-k="down">&#9660;</div><div class="td empty"></div>
      </div>
      <div class="tact" data-p="2" data-k="act">ACT</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const startOverlay = document.getElementById('start-overlay');
    const msgOverlay = document.getElementById('msg-overlay');
    const msgTitle = document.getElementById('msg-title');
    const msgSub = document.getElementById('msg-sub');
    const hud = document.getElementById('hud');
    const hp1 = document.getElementById('hp1');
    const hp2 = document.getElementById('hp2');
    const hp3 = document.getElementById('hp3');
    const sep3 = document.getElementById('sep3');
    const hudInfo = document.getElementById('hud-info');

    let W, H;
    function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
    window.addEventListener('resize', resize);
    resize();

    // ‚îÄ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ
    const keys = {};
    document.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
    });
    document.addEventListener('keyup', e => { keys[e.key] = false; });

    // Local 2P touch
    const touchLocal = { 1: {}, 2: {} };
    document.querySelectorAll('[data-p]').forEach(el => {
      const p = el.dataset.p, k = el.dataset.k;
      el.addEventListener('touchstart', e => { e.preventDefault(); touchLocal[p][k] = true; }, { passive: false });
      el.addEventListener('touchend', e => { e.preventDefault(); touchLocal[p][k] = false; }, { passive: false });
      el.addEventListener('touchcancel', () => { touchLocal[p][k] = false; });
    });

    // Online single-player touch
    const touchOnline = {};
    document.querySelectorAll('#touch-controls [data-k]').forEach(el => {
      const k = el.dataset.k;
      el.addEventListener('touchstart', e => { e.preventDefault(); touchOnline[k] = true; }, { passive: false });
      el.addEventListener('touchend', e => { e.preventDefault(); touchOnline[k] = false; }, { passive: false });
      el.addEventListener('touchcancel', () => { touchOnline[k] = false; });
    });

    // ‚îÄ‚îÄ‚îÄ Field Constants ‚îÄ‚îÄ‚îÄ
    const FIELD_YARDS = 100;
    const ENDZONE_W = 40;
    const PLAYER_R = 14;
    const PLAYER_SPEED = 3.5;
    const SPRINT_SPEED = 5.2;
    const TACKLE_RANGE = 30;
    const DIVE_RANGE = 50;
    const BALL_R = 6;

    const PLAYER_COLORS = ['#4fc3f7', '#ff8800', '#66bb6a'];
    const PLAYER_INNER  = ['#3aa0d0', '#cc6600', '#438a46'];

    let fieldX, fieldY, fieldW, fieldH, yardW;
    function calcField() {
      fieldW = Math.min(W - 40, 800);
      fieldH = Math.min(H - 100, 360);
      fieldX = (W - fieldW) / 2;
      fieldY = (H - fieldH) / 2;
      yardW = (fieldW - ENDZONE_W * 2) / FIELD_YARDS;
    }

    function yardToX(yard) { return fieldX + ENDZONE_W + yard * yardW; }
    function xToYard(x) { return (x - fieldX - ENDZONE_W) / yardW; }

    // ‚îÄ‚îÄ‚îÄ Networking ‚îÄ‚îÄ‚îÄ
    let netMode = 'local'; // 'local' | 'host' | 'guest'
    let peer = null;
    let conns = [];
    let remoteInputs = {}; // { playerId: {up,down,left,right,act} }
    let myPlayerId = 1;
    let numPlayers = 2; // 2 for local, 3 for online
    let TOTAL_DRIVES = 8;

    // ‚îÄ‚îÄ‚îÄ Game State ‚îÄ‚îÄ‚îÄ
    let scores, driveNum, offense;
    let players, ballCarrier, ball, thrownBall;
    let lineOfScrimmage, down, yardsToGo, firstDownLine;
    let gameStarted, playing, pauseTimer, particles;
    let actPressedState; // per-player act tracking

    function makePlayer(x, y, color, id) {
      return { x, y, color, id, vx: 0, vy: 0, diving: false, diveTimer: 0 };
    }

    function setupDrive() {
      lineOfScrimmage = 20;
      down = 1;
      yardsToGo = 10;
      firstDownLine = lineOfScrimmage + 10;
      thrownBall = null;
      setupPlay();
    }

    function setupPlay() {
      const losX = yardToX(lineOfScrimmage);
      const cy = fieldY + fieldH / 2;
      thrownBall = null;

      if (numPlayers === 2) {
        // 2-player local mode
        if (offense === 1) {
          players = [
            makePlayer(losX - 10, cy, PLAYER_COLORS[0], 1),
            makePlayer(losX + 40, cy, PLAYER_COLORS[1], 2),
          ];
          ballCarrier = players[0];
        } else {
          players = [
            makePlayer(losX + 40, cy, PLAYER_COLORS[0], 1),
            makePlayer(losX - 10, cy, PLAYER_COLORS[1], 2),
          ];
          ballCarrier = players[1];
        }
      } else {
        // 3-player online mode
        players = [];
        const offIdx = offense - 1;
        // Offense player at snap position
        players.push(makePlayer(losX - 10, cy, PLAYER_COLORS[offIdx], offense));
        // Defenders spread out
        const defIds = [1,2,3].filter(id => id !== offense);
        const defSpread = fieldH * 0.3;
        players.push(makePlayer(losX + 40, cy - defSpread/2, PLAYER_COLORS[defIds[0]-1], defIds[0]));
        players.push(makePlayer(losX + 40, cy + defSpread/2, PLAYER_COLORS[defIds[1]-1], defIds[1]));
        ballCarrier = players[0]; // offense player is always first in array for setup
      }

      ball = { x: ballCarrier.x, y: ballCarrier.y };
      updateHUD();
    }

    function init() {
      calcField();
      scores = numPlayers === 2 ? [0, 0] : [0, 0, 0];
      driveNum = 1;
      offense = 1;
      playing = true;
      pauseTimer = 0;
      particles = [];
      actPressedState = {};
      setupDrive();
      updateScoreUI();
    }

    function updateScoreUI() {
      hp1.textContent = `P1: ${scores[0]}`;
      hp2.textContent = `P2: ${scores[1]}`;
      if (numPlayers === 3) {
        hp3.textContent = `P3: ${scores[2]}`;
        hp3.style.display = '';
        sep3.style.display = '';
      } else {
        hp3.style.display = 'none';
        sep3.style.display = 'none';
      }
    }

    function updateHUD() {
      const downNames = ['', '1st', '2nd', '3rd', '4th'];
      const offLabel = `P${offense}`;
      const offColor = PLAYER_COLORS[offense - 1];
      hudInfo.innerHTML = `<span style="color:${offColor}">${offLabel} ball</span> &bull; ${downNames[down]} & ${Math.round(yardsToGo)}`;
    }

    function spawnParticles(x, y, color, count, speed) {
      for (let i = 0; i < count; i++) {
        const a = Math.random()*Math.PI*2, s = Math.random()*speed+1;
        particles.push({ x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s,
          radius:Math.random()*3+1, color, life:400+Math.random()*300, maxLife:700 });
      }
    }

    function showMessage(title, sub, duration, callback) {
      msgOverlay.classList.remove('hidden');
      msgTitle.innerHTML = title;
      msgSub.textContent = sub;
      playing = false;
      pauseTimer = duration;
      // If host, broadcast message to guests
      if (netMode === 'host') {
        broadcast({ type: 'msg', title, sub, duration });
      }
      setTimeout(() => {
        msgOverlay.classList.add('hidden');
        if (callback) callback();
        playing = true;
      }, duration);
    }

    function showMessageLocal(title, sub, duration) {
      // Used by guests to show messages without callbacks
      msgOverlay.classList.remove('hidden');
      msgTitle.innerHTML = title;
      msgSub.textContent = sub;
      setTimeout(() => { msgOverlay.classList.add('hidden'); }, duration);
    }

    function handleTouchdown() {
      scores[offense - 1] += 7;
      updateScoreUI();
      const scorer = `P${offense}`;
      const color = PLAYER_COLORS[offense - 1];
      spawnParticles(ballCarrier.x, ballCarrier.y, '#f0a500', 30, 8);
      spawnParticles(ballCarrier.x, ballCarrier.y, color, 20, 6);
      showMessage(`<span style="color:#f0a500">TOUCHDOWN!</span>`, `${scorer} scores! +7 points`, 2000, () => {
        nextDrive();
      });
    }

    function handleTackle() {
      spawnParticles(ballCarrier.x, ballCarrier.y, '#ff4444', 15, 5);
      const newYard = xToYard(ballCarrier.x);

      if (newYard >= firstDownLine) {
        lineOfScrimmage = newYard;
        down = 1;
        yardsToGo = 10;
        firstDownLine = Math.min(lineOfScrimmage + 10, FIELD_YARDS);
        showMessage('<span style="color:#53d769">FIRST DOWN!</span>', '', 1200, () => { setupPlay(); });
        return;
      }

      down++;
      yardsToGo = firstDownLine - newYard;
      lineOfScrimmage = newYard;

      if (down > 4) {
        showMessage('<span style="color:#e94560">TURNOVER ON DOWNS!</span>', '', 1500, () => { nextDrive(); });
        return;
      }

      showMessage(`<span style="color:#aaa">TACKLED</span>`, `${['','1st','2nd','3rd','4th'][down]} & ${Math.round(yardsToGo)}`, 1200, () => { setupPlay(); });
    }

    function handleInterception(catcherId) {
      const color = PLAYER_COLORS[catcherId - 1];
      spawnParticles(thrownBall.x, thrownBall.y, color, 20, 6);
      showMessage(`<span style="color:${color}">INTERCEPTION!</span>`, `P${catcherId} picks it off!`, 1800, () => { nextDrive(); });
    }

    function handleIncomplete() {
      down++;
      yardsToGo = firstDownLine - lineOfScrimmage;
      if (down > 4) {
        showMessage('<span style="color:#e94560">TURNOVER ON DOWNS!</span>', '', 1500, () => { nextDrive(); });
        return;
      }
      showMessage('<span style="color:#aaa">INCOMPLETE</span>', `${['','1st','2nd','3rd','4th'][down]} & ${Math.round(yardsToGo)}`, 1000, () => { setupPlay(); });
    }

    function handleSafety() {
      // In 3P, defenders share the safety points... just give 2 to each defender? No ‚Äî give 1 each for 3P, or 2 for 2P.
      if (numPlayers === 2) {
        const defId = offense === 1 ? 2 : 1;
        scores[defId - 1] += 2;
      } else {
        // Each defender gets 1 point (2 total distributed)
        for (let i = 1; i <= 3; i++) {
          if (i !== offense) scores[i - 1] += 1;
        }
      }
      updateScoreUI();
      const defColor = numPlayers === 2
        ? PLAYER_COLORS[offense === 1 ? 1 : 0]
        : '#aaa';
      spawnParticles(ballCarrier.x, ballCarrier.y, defColor, 20, 6);
      showMessage(`<span style="color:${defColor}">SAFETY!</span>`, `Defense gets 2 points!`, 1800, () => { nextDrive(); });
    }

    function nextDrive() {
      driveNum++;
      if (driveNum > TOTAL_DRIVES) {
        gameOver();
        return;
      }
      if (numPlayers === 2) {
        offense = offense === 1 ? 2 : 1;
      } else {
        offense = (offense % 3) + 1; // 1‚Üí2‚Üí3‚Üí1
      }
      setupDrive();
    }

    function gameOver() {
      let winner, wColor;
      if (numPlayers === 2) {
        winner = scores[0] > scores[1] ? 'P1 WINS!' : scores[1] > scores[0] ? 'P2 WINS!' : 'TIE GAME!';
        wColor = scores[0] > scores[1] ? PLAYER_COLORS[0] : scores[1] > scores[0] ? PLAYER_COLORS[1] : '#aaa';
        const subText = `${scores[0]} - ${scores[1]}`;
        finishGame(winner, wColor, subText);
      } else {
        const maxScore = Math.max(...scores);
        const winners = scores.reduce((acc, s, i) => s === maxScore ? [...acc, i+1] : acc, []);
        if (winners.length === 1) {
          winner = `P${winners[0]} WINS!`;
          wColor = PLAYER_COLORS[winners[0]-1];
        } else {
          winner = 'TIE GAME!';
          wColor = '#aaa';
        }
        const subText = `P1: ${scores[0]}  P2: ${scores[1]}  P3: ${scores[2]}`;
        finishGame(winner, wColor, subText);
      }
    }

    function finishGame(winner, wColor, subText) {
      if (netMode === 'host') {
        broadcast({ type: 'msg', title: `<span style="color:${wColor}">${winner}</span>`, sub: subText + ' \u2022 Tap to play again', duration: 99999 });
      }
      msgOverlay.classList.remove('hidden');
      msgTitle.innerHTML = `<span style="color:${wColor}">${winner}</span>`;
      msgSub.textContent = subText + ' \u2022 Tap to play again';
      playing = false;
      setTimeout(() => {
        const restart = () => {
          document.removeEventListener('click', restart);
          document.removeEventListener('keydown', restart);
          msgOverlay.classList.add('hidden');
          if (netMode === 'host') {
            broadcast({ type: 'restart' });
          }
          init();
        };
        document.addEventListener('click', restart);
        document.addEventListener('keydown', restart);
      }, 1200);
    }

    // ‚îÄ‚îÄ‚îÄ Input reading ‚îÄ‚îÄ‚îÄ
    function getLocalInput(playerId) {
      if (netMode !== 'local') {
        // Online: use keyboard + touch as unified input for this player
        return {
          up: !!(keys['w']||keys['W']||keys['ArrowUp']||touchOnline.up),
          down: !!(keys['s']||keys['S']||keys['ArrowDown']||touchOnline.down),
          left: !!(keys['a']||keys['A']||keys['ArrowLeft']||touchOnline.left),
          right: !!(keys['d']||keys['D']||keys['ArrowRight']||touchOnline.right),
          act: !!(keys[' ']||keys['Enter']||touchOnline.act),
        };
      }
      // Local 2P mode
      if (playerId === 1) {
        return {
          up: !!(keys['w']||keys['W']||touchLocal[1].up),
          down: !!(keys['s']||keys['S']||touchLocal[1].down),
          left: !!(keys['a']||keys['A']||touchLocal[1].left),
          right: !!(keys['d']||keys['D']||touchLocal[1].right),
          act: !!(keys[' ']||touchLocal[1].act),
        };
      } else {
        return {
          up: !!(keys['ArrowUp']||touchLocal[2].up),
          down: !!(keys['ArrowDown']||touchLocal[2].down),
          left: !!(keys['ArrowLeft']||touchLocal[2].left),
          right: !!(keys['ArrowRight']||touchLocal[2].right),
          act: !!(keys['Enter']||touchLocal[2].act),
        };
      }
    }

    function getInputForPlayer(playerId) {
      if (netMode === 'local') {
        return getLocalInput(playerId);
      }
      // Online: host reads own input for myPlayerId, remote for others
      if (playerId === myPlayerId) {
        return getLocalInput(playerId);
      }
      return remoteInputs[playerId] || { up:false, down:false, left:false, right:false, act:false };
    }

    // ‚îÄ‚îÄ‚îÄ Update ‚îÄ‚îÄ‚îÄ
    let lastTs = null;
    function update(dt) {
      if (!playing) {
        for (let i = particles.length-1; i>=0; i--) {
          const p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.life-=dt;
          if (p.life<=0) particles.splice(i,1);
        }
        return;
      }

      // Read all inputs and compute act taps
      const inputsNow = {};
      const actTaps = {};
      for (let pid = 1; pid <= numPlayers; pid++) {
        inputsNow[pid] = getInputForPlayer(pid);
        const wasPressed = actPressedState[pid] || false;
        actTaps[pid] = inputsNow[pid].act && !wasPressed;
        actPressedState[pid] = inputsNow[pid].act;
      }

      for (const p of players) {
        if (p.diving) {
          p.diveTimer -= dt;
          p.x += p.vx; p.y += p.vy;
          p.vx *= 0.94; p.vy *= 0.94;
          if (p.diveTimer <= 0) { p.diving = false; }
          continue;
        }

        const inp = inputsNow[p.id];
        let dx = 0, dy = 0;
        if (inp.up) dy = -1;
        if (inp.down) dy = 1;
        if (inp.left) dx = -1;
        if (inp.right) dx = 1;

        const actTap = actTaps[p.id];
        const actHold = inp.act;

        if (dx || dy) { const l = Math.hypot(dx,dy); dx/=l; dy/=l; }

        const isOffense = p.id === offense;
        const isBallCarrier = ballCarrier === p;
        const spd = (actHold && !actTap) ? SPRINT_SPEED : PLAYER_SPEED;
        p.x += dx * spd;
        p.y += dy * spd;

        // Clamp to field
        p.x = Math.max(fieldX + PLAYER_R, Math.min(fieldX + fieldW - PLAYER_R, p.x));
        p.y = Math.max(fieldY + PLAYER_R, Math.min(fieldY + fieldH - PLAYER_R, p.y));

        // Offense action: throw ball
        if (isOffense && isBallCarrier && actTap && !thrownBall) {
          const throwAngle = Math.atan2(dy, dx || 1);
          thrownBall = {
            x: p.x, y: p.y,
            vx: Math.cos(throwAngle) * 9 + 3,
            vy: Math.sin(throwAngle) * 5,
            life: 800,
          };
          ballCarrier = null;
        }

        // Defense action: dive tackle
        if (!isOffense && actTap) {
          const target = ballCarrier || (thrownBall ? { x: thrownBall.x, y: thrownBall.y } : null);
          if (target) {
            const a = Math.atan2(target.y - p.y, target.x - p.x);
            p.vx = Math.cos(a) * 8;
            p.vy = Math.sin(a) * 8;
            p.diving = true;
            p.diveTimer = 400;
          }
        }
      }

      // Player collision (all pairs)
      for (let i = 0; i < players.length; i++) {
        for (let j = i+1; j < players.length; j++) {
          const a = players[i], b = players[j];
          const pd = Math.hypot(a.x-b.x, a.y-b.y);
          if (pd < PLAYER_R * 2 && pd > 0) {
            const overlap = PLAYER_R*2 - pd;
            const ax = (a.x-b.x)/pd, ay = (a.y-b.y)/pd;
            a.x += ax*overlap/2; a.y += ay*overlap/2;
            b.x -= ax*overlap/2; b.y -= ay*overlap/2;
          }
        }
      }

      // Tackle check
      if (ballCarrier) {
        const defenders = players.filter(p => p.id !== offense);
        for (const defender of defenders) {
          const dist = Math.hypot(ballCarrier.x - defender.x, ballCarrier.y - defender.y);
          const range = defender.diving ? DIVE_RANGE : TACKLE_RANGE;
          if (dist < range) {
            handleTackle();
            return;
          }
        }

        ball.x = ballCarrier.x;
        ball.y = ballCarrier.y;

        const yard = xToYard(ballCarrier.x);
        if (yard >= FIELD_YARDS) { handleTouchdown(); return; }
        if (yard < 0) { handleSafety(); return; }
      }

      // Thrown ball
      if (thrownBall) {
        thrownBall.x += thrownBall.vx;
        thrownBall.y += thrownBall.vy;
        thrownBall.life -= dt;
        ball.x = thrownBall.x;
        ball.y = thrownBall.y;

        // Defense catch (interception)
        const defenders = players.filter(p => p.id !== offense);
        for (const defender of defenders) {
          if (Math.hypot(thrownBall.x - defender.x, thrownBall.y - defender.y) < PLAYER_R + BALL_R + 5) {
            handleInterception(defender.id);
            return;
          }
        }

        if (thrownBall.life <= 0 ||
            thrownBall.x < fieldX || thrownBall.x > fieldX + fieldW ||
            thrownBall.y < fieldY || thrownBall.y > fieldY + fieldH) {
          handleIncomplete();
          return;
        }

        if (xToYard(thrownBall.x) >= FIELD_YARDS) {
          handleIncomplete();
          return;
        }
      }

      // Particles
      for (let i = particles.length-1; i>=0; i--) {
        const p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.life-=dt;
        if (p.life<=0) particles.splice(i,1);
      }
    }

    // ‚îÄ‚îÄ‚îÄ Draw ‚îÄ‚îÄ‚îÄ
    function draw() {
      calcField();
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, W, H);

      // End zones
      ctx.fillStyle = 'rgba(79,195,247,0.15)';
      ctx.fillRect(fieldX, fieldY, ENDZONE_W, fieldH);
      ctx.fillStyle = 'rgba(255,136,0,0.15)';
      ctx.fillRect(fieldX + fieldW - ENDZONE_W, fieldY, ENDZONE_W, fieldH);

      // Endzone text
      ctx.save();
      ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(79,195,247,0.3)';
      ctx.translate(fieldX + ENDZONE_W/2, fieldY + fieldH/2);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('END ZONE', 0, 0);
      ctx.restore();
      ctx.save();
      ctx.font = 'bold 20px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillStyle = 'rgba(255,136,0,0.3)';
      ctx.translate(fieldX + fieldW - ENDZONE_W/2, fieldY + fieldH/2);
      ctx.rotate(Math.PI/2);
      ctx.fillText('END ZONE', 0, 0);
      ctx.restore();

      // Field green
      const playFieldX = fieldX + ENDZONE_W;
      const playFieldW = fieldW - ENDZONE_W * 2;
      ctx.fillStyle = '#1a5c2e';
      ctx.fillRect(playFieldX, fieldY, playFieldW, fieldH);

      // Yard lines
      ctx.strokeStyle = 'rgba(255,255,255,0.2)'; ctx.lineWidth = 1;
      ctx.font = 'bold 10px sans-serif'; ctx.textAlign = 'center'; ctx.fillStyle = 'rgba(255,255,255,0.25)';
      for (let yd = 0; yd <= 100; yd += 5) {
        const x = yardToX(yd);
        if (yd % 10 === 0) {
          ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 1.5;
        } else {
          ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1;
        }
        ctx.beginPath(); ctx.moveTo(x, fieldY); ctx.lineTo(x, fieldY + fieldH); ctx.stroke();
        if (yd % 10 === 0 && yd > 0 && yd < 100) {
          const label = yd <= 50 ? yd : 100 - yd;
          ctx.fillText(label, x, fieldY + 14);
          ctx.fillText(label, x, fieldY + fieldH - 8);
        }
      }

      // Hash marks
      ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 1;
      const hashY1 = fieldY + fieldH * 0.33;
      const hashY2 = fieldY + fieldH * 0.67;
      for (let yd = 1; yd < 100; yd++) {
        if (yd % 5 === 0) continue;
        const x = yardToX(yd);
        ctx.beginPath(); ctx.moveTo(x, hashY1 - 4); ctx.lineTo(x, hashY1 + 4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x, hashY2 - 4); ctx.lineTo(x, hashY2 + 4); ctx.stroke();
      }

      // Line of scrimmage
      const losX = yardToX(lineOfScrimmage);
      ctx.strokeStyle = 'rgba(79,195,247,0.5)'; ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath(); ctx.moveTo(losX, fieldY); ctx.lineTo(losX, fieldY + fieldH); ctx.stroke();
      ctx.setLineDash([]);

      // First down line
      if (firstDownLine <= FIELD_YARDS) {
        const fdX = yardToX(firstDownLine);
        ctx.strokeStyle = 'rgba(255,255,0,0.5)'; ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(fdX, fieldY); ctx.lineTo(fdX, fieldY + fieldH); ctx.stroke();
        ctx.setLineDash([]);
      }

      // Field border
      ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 3;
      ctx.strokeRect(fieldX, fieldY, fieldW, fieldH);

      if (!players) return;

      // Players
      for (const p of players) {
        const isOff = p.id === offense;
        const colorIdx = p.id - 1;

        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath(); ctx.ellipse(p.x+2, p.y+3, PLAYER_R, PLAYER_R*0.5, 0, 0, Math.PI*2); ctx.fill();

        // Body
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color; ctx.shadowBlur = 8;
        if (p.diving) {
          ctx.save();
          const da = Math.atan2(p.vy, p.vx);
          ctx.translate(p.x, p.y);
          ctx.rotate(da);
          ctx.beginPath(); ctx.ellipse(0, 0, PLAYER_R * 1.4, PLAYER_R * 0.7, 0, 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        } else {
          ctx.beginPath(); ctx.arc(p.x, p.y, PLAYER_R, 0, Math.PI*2); ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Inner
        ctx.fillStyle = PLAYER_INNER[colorIdx];
        if (!p.diving) {
          ctx.beginPath(); ctx.arc(p.x, p.y, PLAYER_R*0.5, 0, Math.PI*2); ctx.fill();
        }

        // Number
        ctx.fillStyle = '#fff'; ctx.font = `bold ${PLAYER_R*0.7}px sans-serif`;
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        if (!p.diving) ctx.fillText(p.id, p.x, p.y+1);

        // Label
        ctx.fillStyle = p.color; ctx.globalAlpha = 0.7;
        ctx.font = 'bold 10px sans-serif';
        const role = isOff ? 'OFF' : 'DEF';
        let label = `P${p.id} ${role}`;
        // Highlight own player in online mode
        if (netMode !== 'local' && p.id === myPlayerId) label = `> P${p.id} ${role} <`;
        ctx.fillText(label, p.x, p.y - PLAYER_R - 8);
        ctx.globalAlpha = 1;
      }

      // Ball
      if (ball) {
        ctx.fillStyle = '#8b4513';
        ctx.shadowColor = '#8b4513'; ctx.shadowBlur = 6;
        ctx.beginPath(); ctx.ellipse(ball.x, ball.y, BALL_R * 1.5, BALL_R, 0, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(ball.x - 3, ball.y); ctx.lineTo(ball.x + 3, ball.y); ctx.stroke();
        for (let i = -1; i <= 1; i++) {
          ctx.beginPath(); ctx.moveTo(ball.x + i * 3, ball.y - 2); ctx.lineTo(ball.x + i * 3, ball.y + 2); ctx.stroke();
        }
      }

      // Thrown ball trail
      if (thrownBall) {
        ctx.globalAlpha = 0.3; ctx.fillStyle = '#8b4513';
        ctx.beginPath(); ctx.ellipse(thrownBall.x - thrownBall.vx, thrownBall.y - thrownBall.vy, BALL_R, BALL_R * 0.6, 0, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
      }

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life / p.maxLife);
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Drive counter
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.font = '12px sans-serif'; ctx.textAlign = 'right';
      ctx.fillText(`Drive ${driveNum}/${TOTAL_DRIVES}`, fieldX + fieldW - 4, fieldY - 6);

      // Show which player you are in online mode
      if (netMode !== 'local') {
        ctx.fillStyle = PLAYER_COLORS[myPlayerId - 1]; ctx.font = 'bold 13px sans-serif'; ctx.textAlign = 'left';
        ctx.fillText(`You are P${myPlayerId}`, fieldX + 4, fieldY - 6);
      }
    }

    // ‚îÄ‚îÄ‚îÄ Network: state sync ‚îÄ‚îÄ‚îÄ
    function broadcast(data) {
      for (const conn of conns) {
        if (conn.open) conn.send(data);
      }
    }

    function buildStateSnapshot() {
      // Convert positions to yard-based coords for screen-size independence
      const pStates = players.map(p => ({
        id: p.id,
        yard: xToYard(p.x),
        yFrac: (p.y - fieldY) / fieldH,
        vx: p.vx, vy: p.vy,
        diving: p.diving, diveTimer: p.diveTimer,
        color: p.color,
      }));
      const bcId = ballCarrier ? ballCarrier.id : 0;
      return {
        type: 'state',
        players: pStates,
        ballYard: xToYard(ball.x),
        ballYFrac: (ball.y - fieldY) / fieldH,
        thrownBall: thrownBall ? {
          yard: xToYard(thrownBall.x),
          yFrac: (thrownBall.y - fieldY) / fieldH,
          vx: thrownBall.vx, vy: thrownBall.vy,
          life: thrownBall.life,
        } : null,
        scores: scores,
        down: down,
        yardsToGo: yardsToGo,
        driveNum: driveNum,
        offense: offense,
        lineOfScrimmage: lineOfScrimmage,
        firstDownLine: firstDownLine,
        ballCarrierId: bcId,
        playing: playing,
      };
    }

    function applyStateSnapshot(s) {
      calcField();
      // Rebuild players from snapshot
      players = s.players.map(ps => {
        const p = makePlayer(
          yardToX(ps.yard),
          fieldY + ps.yFrac * fieldH,
          ps.color,
          ps.id
        );
        p.vx = ps.vx; p.vy = ps.vy;
        p.diving = ps.diving; p.diveTimer = ps.diveTimer;
        return p;
      });

      ball = {
        x: yardToX(s.ballYard),
        y: fieldY + s.ballYFrac * fieldH,
      };

      if (s.thrownBall) {
        thrownBall = {
          x: yardToX(s.thrownBall.yard),
          y: fieldY + s.thrownBall.yFrac * fieldH,
          vx: s.thrownBall.vx, vy: s.thrownBall.vy,
          life: s.thrownBall.life,
        };
      } else {
        thrownBall = null;
      }

      ballCarrier = s.ballCarrierId ? players.find(p => p.id === s.ballCarrierId) || null : null;
      scores = s.scores;
      down = s.down;
      yardsToGo = s.yardsToGo;
      driveNum = s.driveNum;
      offense = s.offense;
      lineOfScrimmage = s.lineOfScrimmage;
      firstDownLine = s.firstDownLine;
      playing = s.playing;

      updateScoreUI();
      updateHUD();
    }

    let sendTimer = 0;
    const SEND_INTERVAL = 50; // ~20Hz

    // ‚îÄ‚îÄ‚îÄ Game Loop ‚îÄ‚îÄ‚îÄ
    function gameLoop(ts) {
      if (!lastTs) lastTs = ts;
      let dt = ts - lastTs; lastTs = ts;
      if (dt > 50) dt = 50;

      if (gameStarted) {
        if (netMode === 'local' || netMode === 'host') {
          update(dt);

          // Host broadcasts state
          if (netMode === 'host') {
            sendTimer += dt;
            if (sendTimer >= SEND_INTERVAL) {
              sendTimer = 0;
              broadcast(buildStateSnapshot());
            }
          }
        } else if (netMode === 'guest') {
          // Guest: only update particles
          for (let i = particles.length-1; i>=0; i--) {
            const p = particles[i]; p.x+=p.vx; p.y+=p.vy; p.vx*=0.95; p.vy*=0.95; p.life-=dt;
            if (p.life<=0) particles.splice(i,1);
          }

          // Send input to host
          const myInput = getLocalInput(myPlayerId);
          if (conns[0] && conns[0].open) {
            conns[0].send({ type: 'input', input: myInput });
          }
        }

        draw();
      }
      requestAnimationFrame(gameLoop);
    }

    // ‚îÄ‚îÄ‚îÄ Lobby Logic ‚îÄ‚îÄ‚îÄ
    const lobbyModeSelect = document.getElementById('lobby-mode-select');
    const lobbyHost = document.getElementById('lobby-host');
    const lobbyJoin = document.getElementById('lobby-join');
    const hostCodeEl = document.getElementById('host-code');
    const hostStatus = document.getElementById('host-status');
    const joinInput = document.getElementById('join-input');
    const joinStatus = document.getElementById('join-status');

    function showLobbyScreen(screen) {
      lobbyModeSelect.style.display = screen === 'select' ? '' : 'none';
      lobbyHost.style.display = screen === 'host' ? '' : 'none';
      lobbyJoin.style.display = screen === 'join' ? '' : 'none';
    }

    function generateCode() {
      const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
      let code = '';
      for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
      return code;
    }

    function startGame() {
      gameStarted = true;
      startOverlay.classList.add('hidden');
      hud.classList.remove('hidden');
      // Show appropriate touch controls
      if (netMode === 'local') {
        document.getElementById('touch-controls').style.display = 'none';
        // Local touch controls shown via CSS media query
      } else {
        document.getElementById('touch-p1-local').style.display = 'none';
        document.getElementById('touch-p2-local').style.display = 'none';
        // Online touch shown via CSS media query on #touch-controls
      }
      init();
    }

    // LOCAL
    document.getElementById('btn-local').addEventListener('click', () => {
      netMode = 'local';
      numPlayers = 2;
      TOTAL_DRIVES = 8;
      startGame();
    });

    // HOST
    document.getElementById('btn-create').addEventListener('click', () => {
      showLobbyScreen('host');
      netMode = 'host';
      numPlayers = 3;
      TOTAL_DRIVES = 9;
      myPlayerId = 1;
      conns = [];
      remoteInputs = {};

      const code = generateCode();
      hostCodeEl.textContent = code;
      hostStatus.textContent = 'Creating room...';
      hostStatus.classList.remove('error');

      peer = new Peer('fb-' + code, { debug: 0 });

      peer.on('open', () => {
        hostStatus.textContent = 'Waiting for players... (0/2 joined)';
      });

      peer.on('error', (err) => {
        if (err.type === 'unavailable-id') {
          hostStatus.textContent = 'Code taken, try again.';
          hostStatus.classList.add('error');
          peer.destroy();
          setTimeout(() => {
            // Auto-retry with new code
            document.getElementById('btn-create').click();
          }, 500);
        } else {
          hostStatus.textContent = 'Error: ' + err.message;
          hostStatus.classList.add('error');
        }
      });

      let nextGuestId = 2;

      peer.on('connection', (conn) => {
        if (conns.length >= 2) {
          conn.on('open', () => {
            conn.send({ type: 'full' });
            conn.close();
          });
          return;
        }

        const guestId = nextGuestId++;
        conn._playerId = guestId;
        conns.push(conn);

        conn.on('open', () => {
          conn.send({ type: 'assign', id: guestId });
          hostStatus.textContent = `Waiting for players... (${conns.length}/2 joined)`;

          if (conns.length === 2) {
            hostStatus.textContent = 'All players joined! Starting...';
            setTimeout(() => {
              broadcast({ type: 'start' });
              startGame();
            }, 800);
          }
        });

        conn.on('data', (data) => {
          if (data.type === 'input') {
            remoteInputs[conn._playerId] = data.input;
          }
        });

        conn.on('close', () => {
          conns = conns.filter(c => c !== conn);
          delete remoteInputs[conn._playerId];
          if (gameStarted) {
            // Player disconnected during game ‚Äî continue but note it
          } else {
            hostStatus.textContent = `Waiting for players... (${conns.length}/2 joined)`;
          }
        });
      });
    });

    document.getElementById('btn-host-back').addEventListener('click', () => {
      if (peer) { peer.destroy(); peer = null; }
      conns = [];
      showLobbyScreen('select');
    });

    // JOIN
    document.getElementById('btn-join').addEventListener('click', () => {
      showLobbyScreen('join');
      joinStatus.textContent = '';
      joinStatus.classList.remove('error');
      joinInput.value = '';
      setTimeout(() => joinInput.focus(), 100);
    });

    document.getElementById('btn-join-back').addEventListener('click', () => {
      if (peer) { peer.destroy(); peer = null; }
      conns = [];
      showLobbyScreen('select');
    });

    function doJoin() {
      const code = joinInput.value.trim().toUpperCase();
      if (code.length < 3) {
        joinStatus.textContent = 'Enter a valid code';
        joinStatus.classList.add('error');
        return;
      }

      joinStatus.textContent = 'Connecting...';
      joinStatus.classList.remove('error');
      document.getElementById('btn-join-go').disabled = true;

      netMode = 'guest';
      numPlayers = 3;
      TOTAL_DRIVES = 9;
      conns = [];

      peer = new Peer(undefined, { debug: 0 });

      peer.on('open', () => {
        const conn = peer.connect('fb-' + code, { reliable: true });

        conn.on('open', () => {
          conns = [conn];
          joinStatus.textContent = 'Connected! Waiting for host to start...';
        });

        conn.on('data', (data) => {
          if (data.type === 'assign') {
            myPlayerId = data.id;
            joinStatus.textContent = `You are Player ${myPlayerId}. Waiting for game to start...`;
          } else if (data.type === 'start') {
            startGame();
          } else if (data.type === 'state') {
            applyStateSnapshot(data);
          } else if (data.type === 'msg') {
            showMessageLocal(data.title, data.sub, data.duration);
          } else if (data.type === 'restart') {
            msgOverlay.classList.add('hidden');
            init();
          } else if (data.type === 'full') {
            joinStatus.textContent = 'Room is full!';
            joinStatus.classList.add('error');
            document.getElementById('btn-join-go').disabled = false;
          }
        });

        conn.on('close', () => {
          joinStatus.textContent = 'Disconnected from host.';
          joinStatus.classList.add('error');
          document.getElementById('btn-join-go').disabled = false;
        });

        conn.on('error', () => {
          joinStatus.textContent = 'Connection error.';
          joinStatus.classList.add('error');
          document.getElementById('btn-join-go').disabled = false;
        });
      });

      peer.on('error', (err) => {
        joinStatus.textContent = 'Could not connect: ' + err.message;
        joinStatus.classList.add('error');
        document.getElementById('btn-join-go').disabled = false;
      });
    }

    document.getElementById('btn-join-go').addEventListener('click', doJoin);
    joinInput.addEventListener('keydown', e => {
      if (e.key === 'Enter') doJoin();
    });

    // ‚îÄ‚îÄ‚îÄ Start ‚îÄ‚îÄ‚îÄ
    gameStarted = false;
    showLobbyScreen('select');
    requestAnimationFrame(gameLoop);

    // ‚îÄ‚îÄ ADMIN PANEL ‚îÄ‚îÄ
    let admOpen4 = false;
    const adm4 = document.createElement('div');
    adm4.style.cssText = 'display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.92);border:2px solid #f0a500;border-radius:14px;padding:24px;z-index:9999;color:#fff;font-family:sans-serif;text-align:center;min-width:240px;';
    adm4.innerHTML = '<div style="font-size:20px;font-weight:bold;color:#f0a500;margin-bottom:16px;">ADMIN</div>' +
      '<button class="ab4" onclick="scores[0]+=7;updateScoreUI()">P1 +7 Points</button>' +
      '<button class="ab4" onclick="scores[1]+=7;updateScoreUI()">P2 +7 Points</button>' +
      '<button class="ab4" onclick="if(ballCarrier){ballCarrier.x=fieldX+fieldW-20;handleTouchdown();}">Auto Touchdown</button>' +
      '<button class="ab4" onclick="lineOfScrimmage=80;setupPlay()">Ball at 80 Yard</button>' +
      '<button class="ab4" onclick="TOTAL_DRIVES=99">Unlimited Drives</button>' +
      '<button class="ab4" onclick="scores=[0,0];updateScoreUI()">Reset Scores</button>';
    const abSt4 = document.createElement('style');
    abSt4.textContent = '.ab4{display:block;width:100%;margin:6px 0;padding:10px;border:1px solid #555;border-radius:8px;background:#1a1a2e;color:#fff;font-size:14px;cursor:pointer;transition:border-color 0.15s;}.ab4:hover{border-color:#f0a500;}';
    document.head.appendChild(abSt4);
    document.body.appendChild(adm4);
    document.addEventListener('keydown', (e) => {
      if (e.key === '`') { admOpen4=!admOpen4; adm4.style.display=admOpen4?'block':'none'; }
    });
  </script>
</body>
</html>
